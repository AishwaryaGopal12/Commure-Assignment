from langchain_community.tools.tavily_search import TavilySearchResults
import os
from langchain.agents import tool
import re, sqlalchemy
from tavily import TavilyClient
from langchain.adapters.openai import convert_openai_messages
from sqlalchemy import create_engine
from pydantic import BaseModel, Field
from sqlalchemy import inspect
from typing import Dict, Any
import sqlite3
from langchain_openai.chat_models import ChatOpenAI


class GeneratedSQL(BaseModel):
    sql_string: str = Field(..., description="SQL statement generated by the LLM")

class ErrorMessage(BaseModel):
    error_string: str = Field(..., description="Error code or message to be checked against documentation")

class SyntaxCheck(BaseModel):
    question: str = Field(..., description="Find a function or syntax in the PostgreSQL documentation")


@tool(args_schema=SyntaxCheck)
def find_sql_function(error_string: str) -> str:
    """
    Will help find the needed functions from Database Documentation to be used while building qquery
    """
    print("Calling find_function")
    tavily_tool = TavilySearchResults(max_results=4,
                                      search_depth="advanced"
                                      )
    return tavily_tool.invoke(error_string)


@tool(args_schema=ErrorMessage)
def check_error(error_string: str) -> str:
    """
    Called with the error code and error description as the argument to get guidance on how to solve the error
    """
    print("Calling check_error")
    client = TavilyClient(os.getenv("TAVILY_API_KEY"))
    content = client.search(error_string, search_depth="advanced")["results"]

    # setup prompt
    prompt = [{
        "role": "system",
        "content": f'You are an AI research assistant. ' \
                   f'Your sole purpose is to give guidance on how to address SQL errors'
    }, {
        "role": "user",
        "content": f'Information: """{content}"""\n\n' \
                   f'Using the above information, answer the following' \
                   f'query: "How to address the SQL error --> {error_string}"' \
        }]

    # run gpt-4
    model = ChatOpenAI(model='gpt-4o',
                       openai_api_key=os.getenv("OPENAI_API_KEY"))
    lc_messages = convert_openai_messages(prompt)
    guidance = model.invoke(lc_messages).content
    return guidance

@tool
def get_schema() -> Dict[str, Any]:
    """
    Introspect a SQLite database and return schema details:
    - columns: name, type, nullable, default, primary_key
    - foreign_keys: column, ref_table, ref_column
    - row_count: number of rows present in the table
    """
    sqlite_url = os.getenv("SQLITE_URL")
    if not sqlite_url.startswith("sqlite:///"):
        raise ValueError("This get_schema is designed for SQLite URLs (sqlite:///...).")

    engine = create_engine(sqlite_url, future=True, pool_pre_ping=True, pool_recycle=300)
    insp = inspect(engine)

    # Extract DB path from sqlite URL for lightweight counting using sqlite3
    db_path = sqlite_url.replace("sqlite:///", "", 1)
    conn_sqlite = sqlite3.connect(db_path)
    conn_sqlite.row_factory = sqlite3.Row
    cur = conn_sqlite.cursor()

    result: Dict[str, Any] = {"dialect": "sqlite", "tables": {}}

    # List user tables (exclude internal sqlite_*)
    tables = [t for t in insp.get_table_names() if not t.startswith("sqlite_")]

    for t in tables:
        # Columns (via SQLAlchemy inspector)
        cols_meta = []
        for col in insp.get_columns(t):
            cols_meta.append({
                "name": col.get("name"),
                "type": str(col.get("type")),
                "nullable": bool(col.get("nullable", True)),
                "default": col.get("default"),
                "primary_key": bool(col.get("primary_key", False)),
            })

        # Foreign keys
        fks_meta = []
        for fk in insp.get_foreign_keys(t):
            referred_table = fk.get("referred_table")
            referred_cols = fk.get("referred_columns") or []
            constrained_cols = fk.get("constrained_columns") or []
            if len(constrained_cols) == len(referred_cols):
                for c, r in zip(constrained_cols, referred_cols):
                    fks_meta.append({"column": c, "ref_table": referred_table, "ref_column": r})
            else:
                for c in constrained_cols:
                    fks_meta.append({"column": c, "ref_table": referred_table, "ref_column": (referred_cols[0] if referred_cols else None)})

        result["tables"][t] = {
            "columns": cols_meta,
            "foreign_keys": fks_meta,
        }

    conn_sqlite.close()
    engine.dispose()
    return result


@tool(args_schema=GeneratedSQL)
def update_delete_drop_insert(sql_string: str) -> str:
    """
    Will validate the SQL to ensure it is not an update, delete, drop or insert query
    """
    if re.search(r"(?i)(update|delete|drop|insert)", sql_string):
        return "The SQL query should not be an update, delete, drop or insert query."
    return "The SQL query is a select statement."

@tool(args_schema=GeneratedSQL)
def validate_sql(sql_string: str) -> str:
    """
    Will validate the SQL to ensure it is syntactically and functionally correct
    """
    print("Calling validate_sql")
    try:
        sqlite_url = os.getenv("SQLITE_URL")
        engine = create_engine(sqlite_url, future=True, pool_pre_ping=True,
                               pool_recycle=300)
        with engine.connect() as conn:
            conn.exec_driver_sql("PRAGMA foreign_keys = ON;")
            conn.execute(sqlalchemy.text("EXPLAIN "+ sql_string))
        return "The SQL query is syntactically and functionally correct."
    except BaseException as e:
        return f"The SQL query is not correct. Error: {e}"